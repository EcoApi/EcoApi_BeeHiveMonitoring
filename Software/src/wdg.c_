#include "wdg.h"
#include "../utils/power.h"

#ifdef USE_IWDG_LL

#include "stm32l4xx_ll_rcc.h"
#include "stm32l4xx_ll_iwdg.h"

// Minimal timeout in microseconds
#define IWDG_TIMEOUT_MIN    ((4*1000000)/LSI_VALUE)
// Maximal timeout in microseconds
#define IWDG_TIMEOUT_MAX    (((256*1000000)/LSI_VALUE) * IWDG_RLR_RL)

#define IS_IWDG_TIMEOUT(X)  (((X) >= IWDG_TIMEOUT_MIN) && ((X) <= IWDG_TIMEOUT_MAX))

// Initialize static variable
static uint8_t b_enabled = FALSE;
static int32_t s32_lastState = WDG_NOT_OCCURED;

static int32_t wdg_set(uint32_t timeout, uint32_t window);
//static void wdg_get(uint32_t *timeout, uint32_t *window);
static uint8_t wdg_isEnabled(void);
//static void wdg_clearReset(void);

/**
  * @brief  Enable IWDG, must be called once
  * @param  timeout: value in microseconds
  * @param  window: optional value in microseconds
  *         Default: IWDG_TIMEOUT_MAX
  * @retval None
  */
int32_t wdg_init(uint32_t timeout /* us */) 
//void wdg_init(uint32_t timeout, uint32_t window)
{
  int32_t s32_ret = OK;
  
  if (!IS_IWDG_TIMEOUT(timeout)) {
    return ERROR;
  }

  if(wdg_isReset(TRUE)) {
    s32_lastState = WDG_OCCURED;
    s32_ret = s32_lastState;
  }  

  // Enable the peripheral clock IWDG
  LL_RCC_LSI_Enable();
  while (LL_RCC_LSI_IsReady() != 1) {
  }

  // Enable the IWDG by writing 0x0000 CCCC in the IWDG_KR register
  LL_IWDG_Enable(IWDG);

  if(wdg_set(timeout, 0/*window*/) != OK)
    return ERROR;

  b_enabled = TRUE;

  return s32_ret;
}


void wdg_uninit(void)
{

}


/**
  * @brief  Reload the counter value with IWDG_RLR (IWDG_KR = 0x0000 AAAA)
  * @retval None
  */
void wdg_reload(void)
{
  if (wdg_isEnabled()) {
    LL_IWDG_ReloadCounter(IWDG);
  }
}

/**
  * @brief  Set the timeout and window values
  * @param  timeout: value in microseconds
  * @param  window: optional value in microseconds
  *         Default: IWDG_TIMEOUT_MAX
  * @retval None
  */
static int32_t wdg_set(uint32_t timeout, uint32_t window)
{
  if ((wdg_isEnabled()) && (!IS_IWDG_TIMEOUT(timeout))) {
    return ERROR;
  }

  // Compute the prescaler value
  uint16_t div = 0;
  uint8_t prescaler = 0;
  uint32_t reload = 0;

  // Convert timeout to seconds
  float t_sec = (float)timeout / 1000000 * LSI_VALUE;

  do {
    div = 4 << prescaler;
    prescaler++;
  } while ((t_sec / div) > IWDG_RLR_RL);

  // 'prescaler' value is one of the LL_IWDG_PRESCALER_XX define
  if (--prescaler > LL_IWDG_PRESCALER_256) {
    return ERROR;
  }
  reload = (uint32_t)(t_sec / div) - 1;

  // Enable register access by writing 0x0000 5555 in the IWDG_KR register
  LL_IWDG_EnableWriteAccess(IWDG);
  // Write the IWDG prescaler by programming IWDG_PR from 0 to 7
  // LL_IWDG_PRESCALER_4 (0) is lowest divider
  LL_IWDG_SetPrescaler(IWDG, (uint32_t)prescaler);
  // Write the reload register (IWDG_RLR)
  LL_IWDG_SetReloadCounter(IWDG, reload);

#ifdef IWDG_WINR_WIN
  if ((window != IWDG_TIMEOUT_MAX) &&
      (LL_IWDG_GetWindow(IWDG) != IWDG_WINR_WIN)) {
    if (window >= timeout) {
      // Reset window value
      reload = IWDG_WINR_WIN;
    } else {
      reload = (uint32_t)(((float)window / 1000000 * LSI_VALUE) / div) - 1;
    }
    LL_IWDG_SetWindow(IWDG, reload);
  }
#else
  UNUSED(window);
#endif

  // Wait for the registers to be updated (IWDG_SR = 0x0000 0000)
  while (LL_IWDG_IsReady(IWDG) != 1) {
  }

  // Refresh the counter value with IWDG_RLR (IWDG_KR = 0x0000 AAAA)
  LL_IWDG_ReloadCounter(IWDG);

  return OK;
}

#if 0
/**
  * @brief  Get the current timeout and window values
  * @param  timeout: pointer to the get the value in microseconds
  * @param  window: optional pointer to the get the value in microseconds
  * @retval None
  */
static void wdg_get(uint32_t *timeout, uint32_t *window)
{
  if (timeout != NULL) {
    uint32_t prescaler = 0;
    uint32_t reload = 0;
    float base = (1000000.0 / LSI_VALUE);

    while (LL_IWDG_IsActiveFlag_RVU(IWDG));
    reload = LL_IWDG_GetReloadCounter(IWDG);

    while (LL_IWDG_IsActiveFlag_PVU(IWDG));
    prescaler = LL_IWDG_GetPrescaler(IWDG);

    // Timeout given in microseconds
    *timeout = (uint32_t)((4 << prescaler) * (reload + 1) * base);
#ifdef IWDG_WINR_WIN
    if (window != NULL) {
      while (LL_IWDG_IsActiveFlag_WVU(IWDG));
      uint32_t win = LL_IWDG_GetWindow(IWDG);
      *window = (uint32_t)((4 << prescaler) * (win + 1) * base);
    }
#else
    UNUSED(window);
#endif
  }
}
#endif

static uint8_t wdg_isEnabled(void)
{
  return b_enabled;
}


/**
  * @brief  Check if the system has resumed from IWDG reset
  * @param  clear: if true clear IWDG reset flag. Default false
  * @retval return reset flag status
  */
uint8_t wdg_isReset(uint8_t clear)
{
#if 0

  uint8_t status = LL_RCC_IsActiveFlag_IWDGRST();

  if (status && clear) {
    wdg_clearReset();
  }

  return status;
#else
  return power_isWatchdogReset();
#endif

  
}

/**
  * @brief  Check if the system has resumed from IWDG reset
  * @param  clear: if true clear IWDG reset flag. Default false
  * @retval return reset flag status
  */
int32_t wdg_getLastState(void)
{
  return s32_lastState;
}


/**
  * @brief  Clear IWDG reset flag
  * @retval None
  */
/*static void wdg_clearReset(void)
{
  LL_RCC_ClearResetFlags();
}*/
#else
static IWDG_HandleTypeDef   IwdgHandle;

int32_t wdg_init(uint32_t timeout /* us */)
{
  uint16_t div = 0;
  uint8_t prescaler = 0;
  uint32_t reload = 0;
  float t_sec;

  /*##-1- Check if the system has resumed from IWDG reset ####################*/
  //if (__HAL_RCC_GET_FLAG(RCC_FLAG_IWDGRST) != RESET)
  //{
    //todo action on reset wdg

  //}

  /* Clear reset flags in any cases */
  //__HAL_RCC_CLEAR_RESET_FLAGS();

  /*##-2- Get the LSI frequency: TIM21 is used to measure the LSI frequency ###*/
  //uwLsiFreq = LSI_VALUE;
  
  // Convert timeout to seconds
  t_sec = (float)timeout / 1000000 * LSI_VALUE;

  do {
    div = 4 << prescaler;
    prescaler++;
  } while ((t_sec / div) > IWDG_RLR_RL);

  if (--prescaler > IWDG_PRESCALER_256) {
    return ERROR;
  }
  
  reload = (uint32_t)(t_sec / div) - 1;

  /*##-3- Configure & Start the IWDG peripheral #########################################*/
  /* Set counter reload value to obtain 1 sec. IWDG TimeOut.
     IWDG counter clock Frequency = uwLsiFreq
     Set Prescaler to 32 (IWDG_PRESCALER_32)
     Timeout Period = (Reload Counter Value * 32) / uwLsiFreq
     So Set Reload Counter Value = (1 * uwLsiFreq) / 32 */
  IwdgHandle.Instance = IWDG;
  IwdgHandle.Init.Prescaler = prescaler;
  IwdgHandle.Init.Reload = reload; /* 12 bit counter */
  IwdgHandle.Init.Window = IWDG_WINDOW_DISABLE;

  if(HAL_IWDG_Init(&IwdgHandle) != HAL_OK)
  {
    /* Initialization Error */
    return ERROR;//rror_Handler();
  }

  return OK;
}

void wdg_uninit(void)
{


}

void wdg_reload(void)
{
  /* Refresh IWDG: reload counter */
    if(HAL_IWDG_Refresh(&IwdgHandle) != HAL_OK)
    {
      /* Refresh Error */
      //Error_Handler();
    }
}

#endif